// Generated by CoffeeScript 1.4.0
(function() {

  window.JLife = (function() {
    var seedGrid;
    seedGrid = function(w, h, state) {
      var x, _i, _ref, _results;
      if (state != null) {
        return state.slice(0);
      } else {
        _results = [];
        for (x = _i = 0, _ref = w * h; 0 <= _ref ? _i <= _ref : _i >= _ref; x = 0 <= _ref ? ++_i : --_i) {
          _results.push(Math.round(Math.random()));
        }
        return _results;
      }
    };
    return function(w, h, state) {
      var game, _cells;
      _cells = [];
      game = {
        cells: seedGrid(w, h, state),
        width: w,
        height: h,
        step: function(num) {
          var alive, buffer, cell, i, iter, _i, _j, _len, _ref, _results;
          if (num == null) {
            num = 1;
          }
          _results = [];
          for (iter = _i = 1; 1 <= num ? _i <= num : _i >= num; iter = 1 <= num ? ++_i : --_i) {
            buffer = this.cells.slice(0);
            _ref = this.cells;
            for (i = _j = 0, _len = _ref.length; _j < _len; i = ++_j) {
              cell = _ref[i];
              alive = this.at(i).neighbors().alive();
              buffer[i] = cell ? +((4 > alive && alive > 1)) : +(alive === 3);
            }
            _results.push(this.cells = buffer);
          }
          return _results;
        },
        at: function(x, y) {
          var cell, grid, pos, _adjacent,
            _this = this;
          grid = this;
          pos = y ? this.width * y + x : x;
          if (_cells[pos]) {
            return _cells[pos];
          }
          _adjacent = [];
          cell = {
            state: this.cells[pos],
            top: function() {
              return pos < _this.width;
            },
            bottom: function() {
              return pos >= _this.width * (_this.height - 1);
            },
            left: function() {
              return pos % _this.width === 0;
            },
            right: function() {
              return pos % _this.width === _this.width - 1;
            },
            neighbors: function() {
              var adjacent, cellIndex, i, n, neighbor, offset, _i, _len;
              if (_adjacent.length) {
                return _adjacent;
              }
              n = [1, 1, 1, 1, 0, 1, 1, 1, 1];
              if (this.top()) {
                n[0] = n[1] = n[2] = 0;
              }
              if (this.bottom()) {
                n[6] = n[7] = n[8] = 0;
              }
              if (this.left()) {
                n[0] = n[3] = n[6] = 0;
              }
              if (this.right()) {
                n[2] = n[5] = n[8] = 0;
              }
              adjacent = [];
              for (i = _i = 0, _len = n.length; _i < _len; i = ++_i) {
                neighbor = n[i];
                if (neighbor) {
                  offset = i - 4;
                  cellIndex = offset < -1 ? grid.width * -1 + (offset + 3) + pos : offset > 1 ? grid.width - (3 - offset) + pos : offset + pos;
                  adjacent.push(cellIndex);
                }
              }
              adjacent.alive = function() {
                var total, _j, _len1;
                total = 0;
                for (_j = 0, _len1 = this.length; _j < _len1; _j++) {
                  neighbor = this[_j];
                  total += grid.cells[neighbor];
                }
                return total;
              };
              _adjacent = adjacent;
              return adjacent;
            }
          };
          _cells[pos] = cell;
          return cell;
        }
      };
      return game;
    };
  })();

}).call(this);
