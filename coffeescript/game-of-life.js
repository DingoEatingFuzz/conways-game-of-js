// Generated by CoffeeScript 1.8.0
(function() {
  "use strict";
  window.GameOfLife = (function() {
    var seedGrid;
    seedGrid = function(w, h, state) {
      var x, _i, _ref, _results;
      if (state != null) {
        return state.slice(0);
      } else {
        _results = [];
        for (x = _i = 1, _ref = w * h; 1 <= _ref ? _i <= _ref : _i >= _ref; x = 1 <= _ref ? ++_i : --_i) {
          _results.push(Math.round(Math.random()));
        }
        return _results;
      }
    };
    return function(w, h, state) {
      var game, _cells;
      _cells = [];
      game = {
        cells: seedGrid(w, h, state),
        width: w,
        height: h,
        top: function(pos) {
          return pos < this.width;
        },
        bottom: function(pos) {
          return pos >= this.width * (this.height - 1);
        },
        left: function(pos) {
          return pos % this.width === 0;
        },
        right: function(pos) {
          return pos % this.width === this.width - 1;
        },
        step: function(num) {
          var alive, buffer, cell, i, iter, _i, _j, _len, _ref, _results;
          if (num == null) {
            num = 1;
          }
          _results = [];
          for (iter = _i = 1; 1 <= num ? _i <= num : _i >= num; iter = 1 <= num ? ++_i : --_i) {
            buffer = this.cells.slice(0);
            _ref = this.cells;
            for (i = _j = 0, _len = _ref.length; _j < _len; i = ++_j) {
              cell = _ref[i];
              alive = this.at(i).neighbors().alive();
              buffer[i] = cell ? +((4 > alive && alive > 1)) : +(alive === 3);
            }
            _results.push(this.cells = buffer);
          }
          return _results;
        },
        at: function(idx) {
          var cell, grid, pos;
          grid = this;
          pos = idx;
          if (_cells[pos]) {
            return _cells[pos];
          }
          cell = {
            state: this.cells[pos],
            neighbors: function() {
              var adjacent, cellIndex, i, n, neighbor, offset, _i, _len;
              n = [1, 1, 1, 1, 0, 1, 1, 1, 1];
              if (grid.top(pos)) {
                n[0] = n[1] = n[2] = 0;
              }
              if (grid.bottom(pos)) {
                n[6] = n[7] = n[8] = 0;
              }
              if (grid.left(pos)) {
                n[0] = n[3] = n[6] = 0;
              }
              if (grid.right(pos)) {
                n[2] = n[5] = n[8] = 0;
              }
              adjacent = [];
              for (i = _i = 0, _len = n.length; _i < _len; i = ++_i) {
                neighbor = n[i];
                if (neighbor) {
                  offset = i - 4;
                  cellIndex = offset < -1 ? grid.width * -1 + (offset + 3) + pos : offset > 1 ? grid.width - (3 - offset) + pos : offset + pos;
                  adjacent.push(cellIndex);
                }
              }
              adjacent.alive = function() {
                var total, _j, _len1;
                total = 0;
                for (_j = 0, _len1 = this.length; _j < _len1; _j++) {
                  neighbor = this[_j];
                  total += grid.cells[neighbor];
                }
                return total;
              };
              this.neighbors = function() {
                return adjacent;
              };
              return adjacent;
            }
          };
          _cells[pos] = cell;
          if (_cells.length === this.width * this.height) {
            this.at = function(idx) {
              return _cells[idx];
            };
          }
          return cell;
        }
      };
      return game;
    };
  })();

}).call(this);
